;;-*-Lisp-*-
(in-package goal)
(bundles "JUN.DGO")
(require "engine/geometry/path.gc")
(require "engine/common-obs/process-taskable.gc")
(require "engine/target/logic-target.gc")
(require "engine/target/sidekick.gc")
(declare-type fisher-fish process-drawable)

(deftype fisher-bank (basic)
  (
    (width       meters)
    (net-radius  meters)
    (net-max-vel  float) ; per second
    (net-accel    float) ; per second
    (net-decel    float) ; per second
    (max-caught   int32)
    (max-missed   int32)
  )
)


(define *fisher-bank*
  (new 'static 'fisher-bank
    :width       (meters   3.3) ;vanilla:  3.3
    :net-radius  (meters   0.7) ;vanilla:  0.7
    :net-max-vel           2.0  ;vanilla:  2.0
    :net-accel            28.0  ;vanilla: 28.0
    :net-decel            15.0  ;vanilla: 15.0
    :max-caught          200    ;;TODO: Add to lump
    :max-missed           20    ;;TODO: Add to lump
  )
)

(defpartgroup group-fish-deadly
  :id 177
  :duration (seconds 0.017)
  :linger-duration (seconds 1.5)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 828) (sp-item 2013)))

(defpart 828
  :init-specs
  ((:texture (bigpuff effects))
   (:num 0.5 0.5)
   (:y (meters 0.2))
   (:scale-x (meters 0.5) (meters 0.5))
   (:scale-y :copy scale-x)
   (:r 128.0 128.0)
   (:b 128.0 128.0)
   (:a 0.0)
   (:vel-x (meters -0.0033333334) (meters 0.006666667))
   (:scalevel-x (meters 0.0033333334))
   (:scalevel-y :copy scalevel-x)
   (:fade-a 0.53333336)
   (:timer (seconds 2))
   (:flags (bit2 bit14))
   (:next-time (seconds 0.035) (seconds 0.177))
   (:next-launcher 829)))

(defpart 829
  :init-specs ((:fade-a -0.21333334)))

(defpart 2013
  :init-specs
  ((:texture (lakedrop effects))
   (:num 0.1 1.0)
   (:x (meters -0.7) (meters 0.5))
   (:z (meters -0.1) (meters 0.2))
   (:scale-x (meters 0.05) (meters 0.1))
   (:scale-y :copy scale-x)
   (:r 255.0)
   (:g 255.0)
   (:b 255.0)
   (:a 32.0 32.0)
   (:fade-a -0.42666668)
   (:accel-y (meters 0.00033333333))
   (:timer (seconds 0.5))
   (:flags (bit2 bit3 bit14))))

(defpartgroup group-fish-normal
  :id 178
  :duration (seconds 0.017)
  :linger-duration (seconds 1.5)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 2001)))

(defpart 2001
  :init-specs
  ((:texture (lakedrop effects))
   (:num 0.1 1.0)
   (:x (meters -0.4) (meters 0.5))
   (:z (meters -0.25) (meters 0.5))
   (:scale-x (meters 0.05) (meters 0.1))
   (:scale-y :copy scale-x)
   (:r 255.0)
   (:g 255.0)
   (:b 255.0)
   (:a 32.0 32.0)
   (:fade-a -0.42666668)
   (:accel-y (meters 0.00033333333))
   (:timer (seconds 0.5))
   (:flags (bit2 bit3 bit14))))

(defpartgroup group-fish-big
  :id 179
  :duration (seconds 0.017)
  :linger-duration (seconds 4)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 830) (sp-item 831)))

(defpart 831
  :init-specs
  ((:texture (starflash effects))
   (:num 2.0)
   (:scale-x (meters 5) (meters 1))
   (:scale-y :copy scale-x)
   (:r 32.0 64.0)
   (:g 128.0 128.0)
   (:a 16.0)
   (:fade-a -1.6)
   (:timer (seconds 0.085))
   (:flags (bit2 bit3))))

(defpart 830
  :init-specs
  ((:texture (flare effects))
   (:num 16.0)
   (:scale-x (meters 2) (meters 2))
   (:rot-x 4)
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y (meters 0.25) (meters 0.5))
   (:r 32.0 64.0)
   (:g 128.0 128.0)
   (:b 0.0)
   (:a 0.0)
   (:scalevel-x (meters 0.009765625))
   (:rotvel-z (degrees -0.3) (degrees 0.6))
   (:scalevel-y (meters 0.009765625))
   (:fade-a 1.2)
   (:timer (seconds 0.5))
   (:flags (bit2 bit3))
   (:func 'sparticle-track-root)
   (:next-time (seconds 0.035) (seconds 0.03))
   (:next-launcher 832)))

(defpart 832
  :init-specs ((:fade-a -0.8)))

(deftype fisher-wave-data (structure)
  (
    (length         time-frame)
    (post-margin    time-frame)
    (vel                 float)
    (swing-min      time-frame)
    (swing-max      time-frame)
    (period         time-frame)
    (fish-vel            float)
    (big-chance         float)
    (deadly-chance      float)
    ;;[ADD-FISH-TYPE] (<FISH-TYPE>-chance float)
  )
  :allow-misaligned
)

(define *fisher-hardmode-cheat*
  (new 'static 'array int 9
    (pad-buttons left)
    (pad-buttons left)
    (pad-buttons right)
    (pad-buttons right)
    (pad-buttons left)
    (pad-buttons left)
    (pad-buttons right)
    (pad-buttons right)
    (pad-buttons x)
  )
)

(define *fisher-max-pity* 4)
(define *fisher-hardmode-idx* 5)

; Mostly for rendering lol
; Real wave counts, actual lengths are +2 from these
(define *fisher-wave-counts*
  (new 'static 'array int 6
     7 ; Pity 0
     7 ; Pity 1
     7 ; Pity 2
     7 ; Pity 3
    12 ; Pity 4
    10 ; Hard Mode
  )
)

(define *fisher-waves*
  (new 'static 'boxed-array :type (inline-array fisher-wave-data)
    ; Pity 0
    (new 'static 'inline-array fisher-wave-data 9
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 0.5)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 10)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.6)
        :fish-vel 1.5
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 8)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.6)
        :fish-vel 1.6
        :big-chance 0.25
        :deadly-chance 0.375)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.45)
        :fish-vel 1.7
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.4)
        :fish-vel 1.8
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.5)
        :fish-vel 1.9
        :big-chance 0.1
        :deadly-chance 0.81)
      (new 'static 'fisher-wave-data
        :length (seconds 2000)
        :post-margin (seconds 2.0)
        :vel 0.8
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.35)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data)
    )

    ; Pity 1
    (new 'static 'inline-array fisher-wave-data 9
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 1)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 11)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.7)
        :fish-vel 1.4
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 9)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.7)
        :fish-vel 1.5
        :big-chance 0.25
        :deadly-chance 0.3)
      (new 'static 'fisher-wave-data
        :length (seconds 18)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.527)
        :fish-vel 1.6
        :big-chance 0.1
        :deadly-chance 0.0747)
      (new 'static 'fisher-wave-data
        :length (seconds 18)
        :post-margin (seconds 2.0)
        :vel 2.41
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.48)
        :fish-vel 1.7
        :big-chance 0.1
        :deadly-chance 0.0747)
      (new 'static 'fisher-wave-data
        :length (seconds 14)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.58)
        :fish-vel 1.8
        :big-chance 0.1
        :deadly-chance 0.72)
      (new 'static 'fisher-wave-data
        :length (seconds 2000)
        :post-margin (seconds 2.0)
        :vel 0.8
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.43)
        :fish-vel 1.8
        :big-chance 0.1
        :deadly-chance 0.0747)
      (new 'static 'fisher-wave-data)
    )

    ; Pity 2
    (new 'static 'inline-array fisher-wave-data 9
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 1.5)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 12)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.8)
        :fish-vel 1.4
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 10)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.8)
        :fish-vel 1.5
        :big-chance 0.25
        :deadly-chance 0.225)
      (new 'static 'fisher-wave-data
        :length (seconds 21)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.61)
        :fish-vel 1.5
        :big-chance 0.1
        :deadly-chance 0.0594)
      (new 'static 'fisher-wave-data
        :length (seconds 21)
        :post-margin (seconds 2.0)
        :vel 1.83
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.56)
        :fish-vel 1.6
        :big-chance 0.1
        :deadly-chance 0.0594)
      (new 'static 'fisher-wave-data
        :length (seconds 14)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.66)
        :fish-vel 1.6
        :big-chance 0.1
        :deadly-chance 0.54)
      (new 'static 'fisher-wave-data
        :length (seconds 2000)
        :post-margin (seconds 2.0)
        :vel 0.8
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.515)
        :fish-vel 1.7
        :big-chance 0.1
        :deadly-chance 0.0594)
      (new 'static 'fisher-wave-data)
    )

    ; Pity 3
    (new 'static 'inline-array fisher-wave-data 9
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 2)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 13)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.3
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 11)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.4
        :big-chance 0.25
        :deadly-chance 0.15)
      (new 'static 'fisher-wave-data
        :length (seconds 23)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.7)
        :fish-vel 1.4
        :big-chance 0.1
        :deadly-chance 0.045)
      (new 'static 'fisher-wave-data
        :length (seconds 23)
        :post-margin (seconds 2.0)
        :vel 1.25
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.65)
        :fish-vel 1.5
        :big-chance 0.1
        :deadly-chance 0.045)
      (new 'static 'fisher-wave-data
        :length (seconds 13)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.75)
        :fish-vel 1.5
        :big-chance 0.1
        :deadly-chance 0.45)
      (new 'static 'fisher-wave-data
        :length (seconds 2000)
        :post-margin (seconds 2.0)
        :vel 0.8
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.6)
        :fish-vel 1.6
        :big-chance 0.1
        :deadly-chance 0.045)
      (new 'static 'fisher-wave-data)
    )

    ; Pity 4
    (new 'static 'inline-array fisher-wave-data 14
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 2.5)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 13)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.3
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 11)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.3
        :big-chance 0.25
        :deadly-chance 0.15)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :swing-max (seconds 0.335)
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :swing-max (seconds 0.335)
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 11)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.3
        :big-chance 0.1
        :deadly-chance 0.045)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :swing-max (seconds 0.335)
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min 99999 ; special value
        :swing-max (seconds 0.335)
        :period (seconds 0.5)
        :fish-vel 1.3
        :big-chance 0.5)
      (new 'static 'fisher-wave-data
        :length (seconds 2000)
        :post-margin (seconds 2.0)
        :vel 0.7
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.9)
        :fish-vel 1.3
        :big-chance 0.1
        :deadly-chance 0.045)
      (new 'static 'fisher-wave-data)
    )

    ; Hard Mode
    (new 'static 'inline-array fisher-wave-data 12
      (new 'static 'fisher-wave-data :length (seconds 2)) ; Empty wave at the beginning of the minigame; Wave "0"
      (new 'static 'fisher-wave-data
        :length (seconds 3)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-max (seconds 0.1)
        :period (seconds 0.5)
        :fish-vel 1.5)
      (new 'static 'fisher-wave-data
        :length (seconds 10)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.6)
        :fish-vel 2.0
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 5)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.6)
        :fish-vel 2.0
        :big-chance 0.25
        :deadly-chance 0.5625)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 0.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.3)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.4)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data
        :length (seconds 15)
        :post-margin (seconds 2.0)
        :vel 3.0
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.4)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.81)
      (new 'static 'fisher-wave-data
        :length (seconds 30)
        :post-margin (seconds 2.0)
        :vel 1.4
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.25)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data
        :length (seconds 30)
        :post-margin (seconds 2.0)
        :vel 1.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.15)
        :fish-vel 2.2
        :big-chance 0.1)
      (new 'static 'fisher-wave-data
        :length (seconds 30)
        :post-margin (seconds 2.0)
        :vel 1.4
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.25)
        :fish-vel 2.0
        :big-chance 0.1
        :deadly-chance 0.18)
      (new 'static 'fisher-wave-data
        :length (seconds 31535998)
        :post-margin (seconds 2.0)
        :vel 1.6
        :swing-min (seconds 0.5)
        :swing-max (seconds 2)
        :period (seconds 0.15)
        :fish-vel 2.2
        :big-chance 0.1
        :deadly-chance 0.09)
      (new 'static 'fisher-wave-data)
    )
  )
)

(deftype fisher (process-taskable)
  (
    (paddle-end      vector 2 :inline)
    (paddle-pos      vector :inline)
    (paddle          float)
    (paddle-vel      float)
    (spawner         float)
    (spawner-last    float)
    (spawn-time      time-frame)
    (turn-time       time-frame)
    (swing-time      time-frame)
    (wave-time       time-frame)
    (wave            int32)
    (caught          int32)
    (missed          int32)
    (pity      int32)
    (start-time      time-frame)
    (ambient-big-one time-frame)
    (ambient-steady  time-frame)
    (ambient-sagging time-frame)
    (ambient-almost  time-frame)
    (cheat-progress      int32)
    (hard            symbol)
    (training        symbol)
    (wave-data       fisher-wave-data :inline)
  )

  (:states
    fisher-done
    fisher-playing
  )
)

(deftype fisher-fish (process-drawable)
  ((dir    vector :inline)
   (offset float)
   (pos    float)
   (vel    float)
   (mode   basic)
   (size   meters))
  (:states
   fisher-fish-caught
   fisher-fish-die
   fisher-fish-fall))


(defskelgroup *catch-fish-normal-sg*
  catch-fisha
  catch-fisha-lod0-jg
  catch-fisha-idle-ja
  ((catch-fisha-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 4))

(defskelgroup *catch-fish-big-sg*
  catch-fishb
  catch-fishb-lod0-jg
  catch-fishb-idle-ja
  ((catch-fishb-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 4))

(defskelgroup *catch-fish-deadly-sg*
  catch-fishc
  catch-fishc-lod0-jg
  catch-fishc-idle-ja
  ((catch-fishc-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 4))

(defskelgroup *fish-net-sg*
  fish-net
  fish-net-lod0-jg
  fish-net-fishing-ja
  ((fish-net-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 0 0 4))

(defskelgroup *fisher-sg*
  fisher
  fisher-lod0-jg
  fisher-idle-more-often-ja
  ((fisher-lod0-mg (meters 20)) (fisher-lod1-mg (meters 40)) (fisher-lod2-mg (meters 999999)))
  :bounds (static-spherem 0 -6 0 14)
  :shadow fisher-shadow-mg)

(defmethod process-taskable-method-52 ((this fisher))
  (let ((v1-1 (-> this draw shadow-ctrl)))
    (when v1-1
      (let ((f0-0 (-> this root trans y)))
        (let ((a0-2 v1-1)) (set! (-> a0-2 settings bot-plane w) (- (+ -1024.0 f0-0))))
        0
        (let ((a0-4 v1-1)) (set! (-> a0-4 settings top-plane w) (- (+ 4096.0 f0-0)))))
      0
      (logclear! (-> v1-1 settings flags) (shadow-flags shdf03))))
  (none))

(defmethod draw-npc-shadow ((this fisher))
  (-> this draw shadow-ctrl)
  (cond
    ((and (-> this draw shadow) (zero? (-> this draw cur-lod)) (logtest? (-> this draw status) (draw-status was-drawn)))
     (let ((v1-9 (-> this draw shadow-ctrl))) (logclear! (-> v1-9 settings flags) (shadow-flags disable-draw)))
     0
     (update-direction-from-time-of-day (-> this draw shadow-ctrl)))
    (else (let ((v1-14 (-> this draw shadow-ctrl))) (logior! (-> v1-14 settings flags) (shadow-flags disable-draw))) 0))
  (none))

(defbehavior fisher-parent fisher-fish ()
  (the-as fisher (-> self parent 0))
)

(defbehavior fisher-fish-water fisher-fish ((arg0 vector) (arg1 float))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (set! (-> gp-0 quad) (-> arg0 quad))
    (set! (-> gp-0 y) (ocean-get-height gp-0))
    (set! (-> *part-id-table* 118 init-specs 4 initial-valuef) (+ 24576.0 arg1))
    (set! (-> *part-id-table* 118 init-specs 19 initial-valuef) (+ 49152.0 arg1))
    (set! (-> *part-id-table* 118 init-specs 1 initial-valuef) 0.05)
    (set! (-> *part-id-table* 118 init-specs 2 initial-valuef) 0.0)
    (set! (-> *part-id-table* 118 init-specs 13 initial-valuef) 0.35555556)
    (launch-particles :system *sp-particle-system-3d* (-> *part-id-table* 118) gp-0))

  (none)
)

(defbehavior fisher-fish-move fisher-fish ()
  (+! (-> self pos) (per-second (-> self vel)))
  (eval-path-curve-div! (-> (fisher-parent) path) (-> self root trans) (-> self pos) 'interp)
  (eval-path-curve-angle (-> (fisher-parent) path) (-> self dir) (-> self pos))
  (seek-toward-heading-vec! (-> self root) (-> self dir) (degrees 1600.0) (seconds 0.2))
  (let (
        (angle (+ (degrees 90.0) (y-angle (-> self root))))
        (gp-0 (new-stack-vector0))
      )
    (set-vector! gp-0
      (sin angle)
      0.0
      (cos angle)
      1.0
    )
    (vector-normalize! gp-0 (* 2.0 (- (-> self offset) 0.5) (-> *fisher-bank* width)))
    (vector+! (-> self root trans) (-> self root trans) gp-0)
  )

  ; Spawn some water particles on the way
  (fisher-fish-water (-> self root trans) (y-angle (-> self root)))
  (if (nonzero? (-> self part))
    (spawn (-> self part) (-> self root trans))
  )

  (none))

(defstate fisher-fish-fall (fisher-fish)
  :code
    (behavior ()
      (set-heading-vec!
        (-> self root)
        (eval-path-curve-angle (-> (fisher-parent) path) (-> self dir) (-> self pos))
      )
      (loop
        (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (fisher-fish-move)
          (if (<
                (vector-vector-xz-distance (-> self root trans) (-> (fisher-parent) paddle-pos))
                (+ (-> *fisher-bank* net-radius) (* (-> self size) (-> self root scale x)))
              )
            (go fisher-fish-caught))
          (if (or
                (>= (-> self pos) (the float (+ (-> (fisher-parent) path curve num-cverts) -1)))
                (>= (-> self pos) 7.2)
              )
            (go fisher-fish-die))
          (suspend)
          (ja :num! (seek!))
        )
      )
    )
  :post ja-post)

(defstate fisher-fish-caught (fisher-fish)
  :code
    (behavior ()
      (case (-> self mode)
        (('deadly)
          (sound-play "caught-eel")
          (ambient-hint-spawn "sksp0a42" (-> self root trans) *entity-pool* 'ambient)
          (send-event (ppointer->process (-> self parent)) 'deadly)
        )
        (('big)
          (process-spawn part-tracker
            :init part-tracker-init
            (-> *part-group-id-table* 179)
            -1
            #f
            #f
            #f
            (-> self root trans)
            :to *entity-pool*
          )
          (sound-play "get-big-fish")
          (send-event (ppointer->process (-> self parent)) 'fisher-fish-caught 5)
        )
        ;;[ADD-FISH-TYPE] Add handling for fish being caught here
        (else
          (process-spawn part-tracker
            :init part-tracker-init
            (-> *part-group-id-table* 179)
            -1
            #f
            #f
            #f
            (-> self root trans)
            :to *entity-pool*
          )
          (sound-play "get-small-fish")
          (send-event (ppointer->process (-> self parent)) 'fisher-fish-caught 1)
        )
      )
      (set! (-> self vel) (/ (-> self vel) 4))
      (while (< 0.1 (-> self root scale x))
        (set! (-> self offset) (-> (fisher-parent) paddle))
        (fisher-fish-move)
        (vector-float*! (-> self root scale) (-> self root scale) 0.93)
        (ja-post)
        (suspend)
        (ja :num! (loop!))
      )
    )
)

(defstate fisher-fish-die (fisher-fish)
  :code (behavior ()
    (case (-> self mode)
      (('deadly))
      (('big)
        (level-hint-spawn (text-id sidekick-hint-fish-powerup) "sksp0b42" (the-as entity #f) *entity-pool* (game-task none))
        (let ((ambient-rng (rand-float-gen)))
          (if (< 0.5 ambient-rng)
            (play-ambient (-> (fisher-parent) ambient) "FIS-TA04" #t (-> self root trans))
            (play-ambient (-> (fisher-parent) ambient) "FIS-TA05" #t (-> self root trans))
          )
        )
        (send-event (ppointer->process (-> self parent)) 'fisher-fish-die 5)
      )
      ;;[ADD-FISH-TYPE] Add handling for fish being missed here
      (else
        (let ((f0-5 (rand-float-gen)))
          (cond
            ((and
                  (< 0.8333 f0-5)
                  (< (-> (fisher-parent) paddle-pos z) (-> self root trans z))
                )
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA01" #t (-> self root trans))
            )
            ((< 0.8333 f0-5)
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA02" #t (-> self root trans))
            )
            ((and
                  (< 0.6666 f0-5)
                  (< (-> (fisher-parent) paddle-pos z) (-> self root trans z))
                )
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA1A" #t (-> self root trans))
            )
            ((< 0.6666 f0-5)
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA2A" #t (-> self root trans))
            )
            ((< 0.5 f0-5)
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA06" #t (-> self root trans))
            )
            ((< 0.3333 f0-5)
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA08" #t (-> self root trans))
            )
            ((< 0.1666 f0-5)
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA09" #t (-> self root trans))
            )
            ((> (-> (fisher-parent) missed) 0)
              (play-ambient (-> (fisher-parent) ambient) "FIS-TA10" #t (-> self root trans))
            )
          )
        )
        (send-event (ppointer->process (-> self parent)) 'fisher-fish-die 1)
      )
    )
  )
)

(defbehavior fisher-fish-init-by-other fisher-fish ((type symbol) (offset float) (vel float))
  (set! (-> self mode) type)
  (logclear! (-> self mask) (process-mask actor-pause))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self size) (meters 0.8))
  (initialize-skeleton self
    (cond
      ((= type 'deadly)
        (set! (-> self size) (meters 0.1))
        (set-vector! (-> self root scale) 0.9 0.9 0.7 1.0)
        (set! (-> self part) (create-launch-control (-> *part-group-id-table* 177) self))
        *catch-fish-deadly-sg*
      )
      ((= type 'big)
        (set-vector! (-> self root scale) 0.4 0.4 0.4 1.0)
        (set! (-> self part) (create-launch-control (-> *part-group-id-table* 178) self))
        *catch-fish-big-sg*
      )
      ;;[ADD-FISH-TYPE] Add initialization here
      (else
        (set-vector! (-> self root scale) 0.3 0.3 0.3 1.0)
        (set! (-> self part) (create-launch-control (-> *part-group-id-table* 178) self))
        *catch-fish-normal-sg*
      )
    )
    '()
  )
  (set! (-> self pos) 1.0)
  (set! (-> self offset) offset)
  (set! (-> self vel) vel)
  (set! (-> self draw force-lod) 0)
  (set! (-> self root transv z) (meters 10.0))
  (set-vector! (-> self draw color-mult) 0.6 0.6 0.6 1.0)
  (set-vector! (-> self draw color-emissive) 0.6 0.6 0.6 0.0)
  (go fisher-fish-fall)
  (none))

(defbehavior fisher-draw-display-pair fisher ((ctx font-context) (text string) (num int))
  (let (
        (text-x 435.0)
        (num-x  488.0)
      )
    (format (clear *temp-string*) "~3D" num)

    (set! (-> ctx origin x) text-x)
    (print-game-text text ctx #f 128 22)

    (set! (-> ctx origin x) num-x)
    (print-game-text *temp-string* ctx #f 128 22)
  )
)

(defbehavior fisher-draw-display-progress fisher ((ctx font-context) (text string) (progress int) (max int))
  (let (
        (text-x 435.0)
        (progress-x (if (< max 10) 468.0 458.0))
        (slash-x (if (< max 10) 478.0 468.0))
        (max-x 488.0)
      )

    (set! (-> ctx origin x) text-x)
    (print-game-text text ctx #f 128 22)

    (set! (-> ctx origin x) progress-x)
    (format (clear *temp-string*) (if (< max 10) "~1D" "~2D") progress)
    (print-game-text *temp-string* ctx #f 128 22)

    (set! (-> ctx origin x) slash-x)
    (print-game-text "/" ctx #f 128 22)

    (set! (-> ctx origin x) max-x)
    (format (clear *temp-string*) (if (< max 10) "~1D" "~2D") max)
    (print-game-text *temp-string* ctx #f 128 22)
  )
)

(defbehavior fisher-draw-display fisher ((this fisher))
  (let* (
        (start-x 435)
        (start-y  10)
        (line-height 15.0)
        (ctx (new 'stack 'font-context *font-default-matrix* start-x start-y 0.0 (font-color red) (font-flags shadow kerning)))
      )
    (set! (-> ctx width) 200.0)
    (set! (-> ctx height) 30.0)
    (set! (-> ctx scale) 0.7)
    (set! (-> ctx flags) (font-flags shadow kerning right large))

    (fisher-draw-display-pair ctx
      (lookup-text! *common-text* (text-id caught) #f)
      (-> this caught)
    )
    (+! (-> ctx origin y) line-height)

    (fisher-draw-display-pair ctx
      (lookup-text! *common-text* (text-id missed) #f)
      (-> this missed)
    )
    (+! (-> ctx origin y) line-height) ; re-used only if Extra HUD is on

    ; Extra HUD displays:
    ; - Wave: XX/YY
    ; - Pity:   XXX
    (when (-> *pc-settings* extra-hud?)
      (fisher-draw-display-progress ctx
        (lookup-text! *common-text* (text-id wave) #f)
        (max 1 (-> this wave)) ; Avoid displaying the initial 2 seconds of wait time as Wave 0
        (-> *fisher-wave-counts* (-> this pity))
      )
      (+! (-> ctx origin y) line-height)

      ; Only render pity if not in hard mode
      (when (not (-> this hard))
        (fisher-draw-display-pair ctx
          (lookup-text! *common-text* (text-id pity) #f)
          (-> this pity)
        )
      )
    )
  )

  (none)
)

(defmethod play-anim! ((this fisher) (arg0 symbol))
  (if arg0 (set! (-> this training) #f))
  (case (current-status (-> this tasks))
    (((task-status need-hint) (task-status need-introduction))
     (when arg0
       (set! (-> this blend-on-exit) (the-as art-joint-anim #t))
       (close-status! (-> this tasks) (task-status need-introduction))
       (set! (-> this training) #t))
     (new 'static
          'spool-anim
          :name "fisher-introduction"
          :index 8
          :parts 9
          :command-list
          '((0 want-levels village1 jungle)
           (0 alive "jungle-part-1")
           (130 blackout 10)
           (130 display-level village1 movie)
           (130 want-force-vis village1 #t)
           (134 blackout 0)
           (229 blackout 10)
           (232 blackout 0)
           (235 display-level village1 #f)
           (235 want-force-vis village1 #f)
           (419 blackout 10)
           (422 blackout 0)
           (518 blackout 10)
           (521 blackout 0)
           (585 blackout 10)
           (588 blackout 0)
           (668 blackout 10)
           (671 blackout 0)
           (848 display-level village1 movie)
           (848 want-force-vis village1 #t)
           (849 alive "fishermans-boat-2")
           (878 blackout 10)
           (881 blackout 0)
           (958 blackout 10)
           (961 blackout 0)
           (965 dead "fishermans-boat-2")
           (965 display-level village1 display)
           (965 want-force-vis village1 #f))))
    (((task-status need-reminder-a) (task-status need-reminder))
     (set! (-> this skippable) #t)
     (set! (-> this blend-on-exit) (the-as art-joint-anim #t))
     (new 'static 'spool-anim :name "fisher-reminder-1" :index 10 :parts 1 :command-list '()))
    (((task-status need-reward-speech))
     (when arg0
       (set! (-> this cell-for-task) (current-task (-> this tasks)))
       (close-current! (-> this tasks)))
     (new 'static 'spool-anim :name "fisher-resolution" :index 9 :parts 4 :command-list '((188 blackout 10) (199 blackout 0))))
    (else
     (if arg0
       (format 0
               "ERROR: <GMJ>: ~S playing anim for task status ~S~%"
               (-> this name)
               (task-status->string (current-status (-> this tasks)))))
     (get-art-elem this))))

(defmethod get-art-elem ((this fisher))
  (if (closed? (-> this tasks) (game-task jungle-fishgame) (task-status need-reminder))
    (-> this draw art-group data 7)
    (-> this draw art-group data 6)))

(defmethod process-taskable-method-38 ((this fisher))
  (case (current-status (-> this tasks))
    (((task-status need-reminder-a) (task-status need-reminder)) (go (method-of-object this query)))
    (((task-status need-reward-speech)) (go (method-of-object this play-anim)))
    (else (call-parent-method this)))
  (none))

(defmethod get-accept-anim ((this fisher) (arg0 symbol))
  (when arg0
    (close-current! (-> this tasks))
    (aybabtu 2))
  (new 'static
       'spool-anim
       :name "fisher-accept"
       :index 12
       :parts 6
       :command-list
       '((0 send-event self emissive-on) (700 send-event self emissive-off))))

(defmethod get-reject-anim ((this fisher) (arg0 symbol))
  (new 'static 'spool-anim :name "fisher-reject" :index 11 :parts 2 :command-list '()))

(defstate fisher-done (fisher)
  :enter
    (behavior ()
      (init!
        (-> self query)
        (lookup-text! *common-text* (text-id play-again?) #f)
        40 150
        30
        #f
        (lookup-text! *common-text* (text-id quit) #f)
      )
      (ja-channel-set! 1)
      (ja :group! (get-art-elem self))
      (set-time! (-> self state-time))
      (while (-> self child)
        (deactivate (-> self child 0)))
      (set! *camera-look-through-other* 2)
      (cond
        ; If we succeeded
        ((>= (-> self caught) (-> *fisher-bank* max-caught))
          (send-event *target* 'end-mode)
          (set! (-> self trans-hook)
            (lambda :behavior fisher ()
              (set! *camera-look-through-other* 2)
              (when (process-grab? *target*)
                (close-current! (-> self tasks))
                (go-virtual play-anim)
              )
              (none)
            )
          )
        )

        ; If we failed
        (else
          ; user-int8 5 -> attempts
          ; user-int8 6 -> pity
          (let ((perm (-> self entity extra perm)))
            (logior! (-> perm status) (entity-perm-status user-set-from-cstage))

            (cond
              ((-> self hard))
              ((and (< (-> self caught) 40) (< (-> self missed) 5)))
              ((and (< (-> self caught) 80) (< (-> self missed) 10)))
              (else
                (set! (-> perm user-int8 4) (the-as int (+ (-> perm user-uint8 4) 1)))
                (let ((caught (-> self caught)))
                  (if (>= caught 90) (set! caught (+ caught -90 caught)))
                  (set! (-> perm user-object 0)
                    (+ (the-as float (-> perm user-object 0)) (* 12.903226 (/ (the float caught) (fmax 5.0 (the float (-> self missed))))))
                  )
                )
              )
            )

            (let ((f0-4 (if (zero? (-> perm user-uint8 4)) 200.0 (/ (the-as float (-> perm user-object 0)) (the float (-> perm user-uint8 4))))))
              (when (zero? (mod (+ (-> perm user-uint8 5) 1) (the-as uint 5))) ; Only every 5 attempts
                (cond
                  ((-> self hard))
                  ((= (-> perm user-uint8 5) 4) ; just lost attempt 4
                    (if (< f0-4 60.0)
                      (set! (-> perm user-int8 6) ; increase pity
                        (seekl (the-as int (-> perm user-uint8 6)) *fisher-max-pity* 1)
                      )
                    )
                    (set! (-> perm user-object 0) 0.0)
                    (set! (-> perm user-int8 4) 0)
                    0)
                  ((= (-> perm user-uint8 5) 9) ; just lost attempt 9
                    (if (< f0-4 120.0)
                      (set! (-> perm user-int8 6) ; increase pity
                        (seekl (the-as int (-> perm user-uint8 6)) *fisher-max-pity* 1)
                      )
                    )
                  )
                  (else ; just lost attempts 14, 19, and so on
                    (set! (-> perm user-int8 6) ; increase pity
                      (seekl (the-as int (-> perm user-uint8 6)) *fisher-max-pity* 1)
                    )
                  )
                )
              )
            )

            ; increment attempts, up to 255
            (set! (-> perm user-int8 5) (seekl (the-as int (-> perm user-uint8 5)) 255 1))

            ; update pity
            (set! (-> self pity) (the-as int (-> perm user-uint8 6)))
            (if (-> self hard) (set! (-> self pity) *fisher-hardmode-idx*))
            
            (format #t
              "fisher: accum ~f  div ~d  tries ~d  diff ~d~%"
              (the-as float (-> perm user-object 0))
              (-> perm user-uint8 4)
              (-> perm user-uint8 5)
              (-> perm user-uint8 6)
            )
          )

          (process-spawn-function process
            (lambda :behavior process ()
              (suspend-for (seconds 0.1))
              (ambient-hint-spawn "st-lose" (the-as vector #f) *entity-pool* 'stinger)
              (none)
            )
          )

          (send-event *target* 'lose)
        )
      )
    )

  :exit
    (behavior ()
      (when (and *target* (the-as target #f))
        (send-event *target* 'end-mode)
        (process-grab? *target*)
      )
    )

  :trans
    (behavior ()
      (set! *camera-look-through-other* 2)
      (cond
        ((>= (-> self caught) (-> *fisher-bank* max-caught)))
        ((< (-> self caught) 0))
        (else
          (when (< (mod (-> *display* base-frame-counter) (seconds 1)) (seconds 0.5))
            ;; og:preserve-this PAL patch here
            (let ((gp-0 (new 'stack 'font-context *font-default-matrix* 56 100 0.0 (font-color red) (font-flags shadow kerning))))
              (let ((v1-10 gp-0)) (set! (-> v1-10 width) (the float 400)))
              (let ((v1-11 gp-0)) (set! (-> v1-11 height) (the float 50)))
              (set! (-> gp-0 flags) (font-flags shadow kerning middle large))
              (print-game-text (lookup-text! *common-text* (text-id lose!) #f) gp-0 #f 128 22)))
          (fisher-draw-display self)
          (let ((gp-1 (get-response (-> self query))))
            (cond
              ((and (= gp-1 'yes) (process-release? *target*))
                (go-virtual enter-playing)
              )
              ((= gp-1 'no)
                (go-virtual play-reject)
              )
            )
          )
        )
      )
      (spool-push *art-control* "fisher-reject" 0 self -99.0)
    )
  :code process-taskable-anim-loop
  :post ja-post)

(defbehavior fisher-spawn-ambient fisher ()
  (let ((ambient-rng (rand-float-gen)))
    (cond
      ((and
            (< 0.3 ambient-rng)
            (< (- (-> *fisher-bank* max-caught) 30) (-> self caught))
          )
        (if (and
              (time-elapsed? (-> self ambient-almost) (seconds 10))
              (play-ambient (-> self ambient) "FIS-TA11" #t (-> self root trans))
            )
          (set-time! (-> self ambient-almost))
        )
      )
      ((< 0.125 ambient-rng))
      ((< 0.1 ambient-rng)
        (if (and
              (time-elapsed? (-> self ambient-steady) (seconds 10))
              (play-ambient (-> self ambient) "FIS-TA06" #t (-> self root trans))
            )
          (set-time! (-> self ambient-steady))
        )
      )
      ((< (- (-> *fisher-bank* max-missed) 6) (-> self missed))
        (if (and
              (time-elapsed? (-> self ambient-sagging) (seconds 10))
              (play-ambient (-> self ambient) "FIS-TA07" #t (-> self root trans))
            )
          (set-time! (-> self ambient-sagging))
        )
      )
    )
  )

  (none)
)

(defbehavior fisher-game-update fisher ()
  ; Try to start next wave
  (when (time-elapsed? (-> self wave-time) (+ (-> self wave-data length) (-> self wave-data post-margin)))
    (set-time! (-> self wave-time))
    (+! (-> self wave) 1)
    (mem-copy!
      (the-as pointer (-> self wave-data))
      (the-as pointer (-> *fisher-waves* (-> self pity) (-> self wave)))
      (asize-of fisher-wave-data)
    )
  )

  ;mod: Since we introduced post-margin to waves, avoid spawning fish in-between waves
  (when (not (time-elapsed? (-> self wave-time) (-> self wave-data length)))
    (when (time-elapsed? (-> self turn-time) (-> self swing-time))
      (set-time! (-> self turn-time))
      (set! (-> self swing-time)
        (rand-vu-int-range
          (the-as int (-> self wave-data swing-min))
          (the-as int (-> self wave-data swing-max))
        )
      )
      (set! (-> self wave-data vel) (- (-> self wave-data vel)))
    )
    (+! (-> self spawner) (* (-> self wave-data vel) (seconds-per-frame)))

    ; Weird way for Pity 4 to give you lines of fish
    (if (= (-> self wave-data swing-min) 99999)
      (set! (-> self spawner) (* 0.01 (the float (-> self wave-data swing-max))))
    )

    ; Clamp the spawner pos
    (cond
      ((and
            (< 0.0 (-> self wave-data vel))
            (>= (-> self spawner) 1.0)
          )
        (set! (-> self wave-data vel) (- (-> self wave-data vel)))
        (set! (-> self spawner) 1.0)
      )
      ((and
            (> 0.0 (-> self wave-data vel))
            (<= (-> self spawner) 0.0)
          )
        (set! (-> self wave-data vel) (- (-> self wave-data vel)))
        (set! (-> self spawner) 0.0)
      )
    )

    ; Try to spawn a fish
    (when (and (nonzero? (-> self wave-data period)) (time-elapsed? (-> self spawn-time) (-> self wave-data period)))
      (let ((fish-type 'normal) (fish-rng (rand-float-gen)) (sum 0.0))
        ; Randomize fish-type
        (+! sum (-> self wave-data big-chance))
        (when (and (= fish-type 'normal) (< fish-rng sum))
          (if (and
                (time-elapsed? (-> self ambient-big-one) (seconds 30))
                (play-ambient (-> self ambient) "FIS-TA03" #t (-> self root trans))
              )
            (set-time! (-> self ambient-big-one))
          )

          (set! fish-type 'big)
        )

        (+! sum (-> self wave-data deadly-chance))
        (when (and (= fish-type 'normal) (< fish-rng sum))
          (set! fish-type 'deadly)
        )

        ;;[ADD-FISH-TYPE]
        ;;(+! sum (-> self wave-data <FISH-TYPE>-chance))
        ;;(when (and (= fish-type 'normal) (< fish-rng sum))
        ;;  (set! fish-type '<FISH-TYPE>)
        ;;)

        (if (and
              (!= fish-type 'deadly)
              (< 0.8 (fdelta (-> self spawner-last) (-> self spawner)))
            )
          (set! (-> self spawner) (* 0.5 (+ (-> self spawner-last) (-> self spawner))))
        )
        (set! (-> self spawner-last) (-> self spawner))
        (set-time! (-> self spawn-time))

        (sound-play "fish-spawn" :vol 70)
        (fisher-spawn-ambient)
        (process-spawn fisher-fish fish-type (-> self spawner) (* 1.85 (-> self wave-data fish-vel)) :to self)
      )
    )
  )

  ; Net control:
  ; 1. Accelerate
  ; 2. Decelerate (even if accelerated)
  ; 3. Clamp Velocity
  ; 4. Apply Velocity
  ; 5. Clamp Position%
  ; 6. Set Position to Position% between start and end points

  (let* ((net-accel (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 32.0 110.0 (-> *fisher-bank* net-accel))))
    (+! (-> self paddle-vel) (per-second net-accel))
  )
  (seek! (-> self paddle-vel) 0.0 (per-second (-> *fisher-bank* net-decel)))
  (fminmax! (-> self paddle-vel) (- (-> *fisher-bank* net-max-vel)) (-> *fisher-bank* net-max-vel))
  (+! (-> self paddle) (per-second (-> self paddle-vel)))
  (fminmax! (-> self paddle) 0.0 1.0)
  (vector-lerp!
    (-> self paddle-pos)
    (the-as vector (-> self paddle-end))
    (the-as vector (&-> self stack 288))
    (-> self paddle)
  )

  (none)
)

(defstate fisher-playing (fisher)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (local-vars (v0-2 object))
      (case message
        (('fisher-fish-die)
          (sound-play "fish-miss")
          (set! v0-2 (+ (-> self missed) (-> block param 0)))
          (set! (-> self missed) (the-as int v0-2))
          v0-2
        )
        (('fisher-fish-caught)
          (send-event *target* 'bounce)
          (set! v0-2 (+ (-> self caught) (-> block param 0)))
          (set! (-> self caught) (the-as int v0-2))
          v0-2
        )
        (('deadly)
          (go fisher-done)
        )
      )
    )
  :enter
    (behavior ()
      (set-setting! 'ambient-volume 'rel 50.0 0)
      (send-event *target* 'reset-pickup 'eco)
      (ja-channel-set! 0)
      (clear-collide-with-as (-> self root))
      (process-spawn-function process
        (lambda :behavior fisher-fish ()
          (logclear! (-> self mask) (process-mask pause))
          (loop
            (fisher-draw-display (the-as fisher (ppointer->process (-> self parent))))
            (suspend))
          (none))
        :to
        self)
      (send-event *camera* 'change-to-entity-by-name "camera-152")
      (init! (-> self query) (the-as string #f) 40 150 25 #t (lookup-text! *common-text* (text-id quit) #f)))
  :exit
    (behavior ()
      (remove-setting! 'ambient-volume)
      (let* ((v1-2 *camera-other-matrix*)
             (a3-0 (-> *camera-combiner* inv-camera-rot))
             (a0-2 (-> a3-0 vector 0 quad))
             (a1-1 (-> a3-0 vector 1 quad))
             (a2-1 (-> a3-0 vector 2 quad))
             (a3-1 (-> a3-0 vector 3 quad)))
        (set! (-> v1-2 vector 0 quad) a0-2)
        (set! (-> v1-2 vector 1 quad) a1-1)
        (set! (-> v1-2 vector 2 quad) a2-1)
        (set! (-> v1-2 vector 3 quad) a3-1))
      (set! (-> *camera-other-fov* data) (-> *camera-combiner* fov))
      (set! (-> *camera-other-trans* quad) (-> *camera-combiner* trans quad))
      (set! (-> *camera-other-root* quad) (-> self root trans quad))
      (restore-collide-with-as (-> self root))
      (send-event *camera* 'blend-from-as-fixed)
      (send-event *camera* 'change-state *camera-base-mode* 0)
      (send-event *camera* 'clear-entity)
      0)
  :trans
    (behavior ()
      (spool-push *art-control* "fisher-resolution" 0 self -99.0)
      (spool-push *art-control* "fisher-reject" 0 self -99.0))
  :code
    (behavior ()
      (set! *display-profile* #f)

      (set! (-> self paddle) 0.5)
      (set! (-> self paddle-vel) 0.0)

      (set-time! (-> self start-time))

      (set! (-> self caught) 0)
      (set! (-> self missed) 0)

      (set! (-> self spawner) 0.5)
      (set! (-> self spawner-last) 0.5)

      (set! (-> self swing-time) 0)

      (set! (-> self wave) 0)
      (set-time! (-> self wave-time))
      (mem-copy!
        (the-as pointer (-> self wave-data))
        (the-as pointer (-> *fisher-waves* (-> self pity) (-> self wave)))
        (asize-of fisher-wave-data)
      )

      (set! (-> self ambient-big-one) 0)
      (set! (-> self ambient-steady) 0)
      (set! (-> self ambient-sagging) 0)
      (set! (-> self ambient-almost) 0)

      (loop
        (hide-hud-quick)
        (fisher-game-update)
        (if (or
              (zero? (-> self wave-data length))
              (>= (-> self missed) (-> *fisher-bank* max-missed))
              (>= (-> self caught) (-> *fisher-bank* max-caught))
            )
          (go fisher-done)
        )
        (suspend)
      )
    )
  :post
    (behavior ()
      (ja-post)))

(defstate enter-playing (fisher)
  :virtual #t
  :trans
    (behavior ()
      (set-blackout-frames (seconds 0.017))
      (if (send-event *target* 'change-mode 'fishing self) (go fisher-playing))))

;; og:preserve-this pc port needs its own implementation of play-anim for cutscene skipping
(#when PC_PORT
  (define *fisher-camera-backup-fov* (degrees 46.2356))
  (define *fisher-camera-backup-trans* (new 'static 'vector :x 1095664.2500 :y 15926.4003 :z -945203.3750 :w 1.0000))
  (define *fisher-camera-backup-matrix*
    (new 'static
         'matrix
         :vector
         (new 'static
              'inline-array
              vector
              4
              (new 'static 'vector :x -0.8677 :y -0.0000 :z 0.4969)
              (new 'static 'vector :x -0.0081 :y 0.9998 :z -0.0141)
              (new 'static 'vector :x -0.4968 :y -0.0163 :z -0.8676)
              (new 'static 'vector :w 1.0))))
  (define *fisher-camera-use-backup* #f)
  (defstate play-anim (fisher)
    :virtual #t
    :enter
      (behavior ()
        (set! *fisher-camera-use-backup* #f)
        ((-> (method-of-type process-taskable play-anim) enter))
        0
        (none))
    :exit
      (behavior ()
        (set! *fisher-camera-use-backup*
              (and (= (get-response (-> self query)) 'no) (or (not (= *cheat-mode* 'debug)) (not (cpad-hold? 0 r1))) (-> self training)))
        (set! (-> self cur-trans-hook)
              (lambda ()
                (when *fisher-camera-use-backup*
                  (set! (-> *camera-other-fov* data) *fisher-camera-backup-fov*)
                  (vector-copy! *camera-other-trans* *fisher-camera-backup-trans*)
                  (matrix-copy! *camera-other-matrix* *fisher-camera-backup-matrix*))
                (none)))
        ((-> (method-of-type process-taskable play-anim) exit))
        0
        (none))))

(defstate query (fisher)
  :virtual #t
  :enter
    (behavior ()
      (init! (-> self query)
             (lookup-text! *common-text* (text-id fish?) #f)
             40
             150
             25
             #f
             (lookup-text! *common-text* (text-id quit) #f)))
  ;; og:preserve-this needed for cutscene skipping
  :exit
  (behavior ()
    (#when PC_PORT
      (set! (-> self cur-trans-hook) nothing))
    ((-> (method-of-type process-taskable play-anim) exit))))

(defmethod process-taskable-method-43 ((this fisher))
  (cond
    ((closed? (-> this tasks) (game-task jungle-fishgame) (task-status need-reminder))
     (when (vector-for-ambient-limited (-> this ambient) (new 'stack-no-clear 'vector) (seconds 1) 122880.0 this)
       (let ((f0-2 (rand-float-gen)))
         (if (< 0.5 f0-2)
           (play-ambient (-> this ambient) "FIS-LO03" #f (-> this root trans))
           (play-ambient (-> this ambient) "FIS-LO05" #f (-> this root trans))))))
    (else
     (when (ambient-control-method-10 (-> this ambient) (new 'stack-no-clear 'vector) (seconds 30) 122880.0 this)
       (let ((f0-5 (rand-float-gen)))
         (cond
           ((< 0.875 f0-5) (play-ambient (-> this ambient) "FIS-LO01" #f (-> this root trans)))
           ((< 0.75 f0-5) (play-ambient (-> this ambient) "FIS-LO04" #f (-> this root trans)))
           ((< 0.625 f0-5) (play-ambient (-> this ambient) "FIS-AM01" #f (-> this root trans)))
           ((< 0.5 f0-5) (play-ambient (-> this ambient) "FIS-AM02" #f (-> this root trans)))
           ((< 0.375 f0-5) (play-ambient (-> this ambient) "FIS-AM03" #f (-> this root trans)))
           ((< 0.25 f0-5) (play-ambient (-> this ambient) "FIS-AM04" #f (-> this root trans)))
           ((< 0.125 f0-5) (play-ambient (-> this ambient) "FIS-AM05" #f (-> this root trans)))
           (else (play-ambient (-> this ambient) "FIS-AM06" #f (-> this root trans)))))))))

(defstate play-accept (fisher)
  :virtual #t
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (local-vars (v0-0 rgbaf))
      (case message
        (('emissive-on)
         (set-vector! (-> self draw color-mult) 0.6 0.6 0.6 1.0)
         (set! v0-0 (-> self draw color-emissive))
         (set! (-> v0-0 x) 0.6)
         (set! (-> v0-0 y) 0.6)
         (set! (-> v0-0 z) 0.6)
         (set! (-> v0-0 w) 0.0)
         v0-0)
        (('emissive-off)
         (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
         (set! v0-0 (-> self draw color-emissive))
         (set! (-> v0-0 x) 0.0)
         (set! (-> v0-0 y) 0.0)
         (set! (-> v0-0 z) 0.0)
         (set! (-> v0-0 w) 0.0)
         v0-0)))
  :trans
    (behavior ()
      (when (-> self training)
        (let ((gp-0 (new-stack-vector0)))
          (vector<-cspace! gp-0 (joint-node fisher-lod0-jg mainA))
          (launch-particles (-> *part-id-table* 2001) gp-0)
          (fisher-fish-water gp-0 (+ 32768.0 (vector-y-angle (-> self node-list data 75 bone transform vector 1))))
          (vector<-cspace! gp-0 (joint-node fisher-lod0-jg mainB))
          (launch-particles (-> *part-id-table* 2001) gp-0)
          (fisher-fish-water gp-0 (+ 32768.0 (vector-y-angle (-> self node-list data 78 bone transform vector 1))))
          (vector<-cspace! gp-0 (joint-node fisher-lod0-jg top))
          (launch-particles (-> *part-id-table* 828) gp-0)
          (launch-particles (-> *part-id-table* 2013) gp-0)
          (fisher-fish-water gp-0 (+ 32768.0 (vector-y-angle (-> self node-list data 80 bone transform vector 1))))))
      (call-parent-state-handler trans)))

(defstate idle (fisher)
  :virtual #t
  :trans
    (behavior ()
      (call-parent-state-handler trans)
      (when (task-complete? *game-info* (-> self entity extra perm task))
        (when (nonzero? (-> *cpad-list* cpads 0 button0-rel 0))
          (if (cpad-pressed-btn? 0 (-> *fisher-hardmode-cheat* (-> self cheat-progress)))
            (+! (-> self cheat-progress) 1)
            (set! (-> self cheat-progress) 0)
          )

          (when (= (-> self cheat-progress) (length *fisher-hardmode-cheat*))
            (set! (-> self hard) #t)
            (set! (-> self pity) *fisher-hardmode-idx*)
            (set! (-> *fisher-bank* max-caught) #x70000000)
            (ambient-hint-spawn "FIS-LO03" (the-as vector #f) *entity-pool* 'stinger)
            (set! (-> self cheat-progress) 0)
          )
        )
      )
    )
  :code
    (behavior ()
      (if (!= (ja-group) (get-art-elem self)) (ja-channel-push! 1 (seconds 0.2)))
      (loop
        (ja :group! (get-art-elem self))
        (let* ((f30-0 5.0)
               (v1-9 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-10 (the-as number (logior #x3f800000 v1-9))))
          (countdown (gp-1 (+ (the int (* f30-0 (+ -1.0 (the-as float v1-10)))) 5))
            (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
            (until (ja-done? 0)
              (process-taskable-method-43 self)
              (suspend)
              (ja :num! (seek!)))))
        (when (ja-group? fisher-idle-more-often-ja)
          (ja-no-eval :group! fisher-idle-less-often-ja :num! (seek!) :frame-num 0.0)
          (until (ja-done? 0)
            (process-taskable-method-43 self)
            (suspend)
            (ja :num! (seek!)))))))

(defmethod initialize-collision ((this fisher) (arg0 int) (arg1 vector))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s4-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s4-0 collide-with) (collide-kind target))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 prim-core offense) (collide-offense indestructible))
      (set-vector! (-> s4-0 local-sphere) 6144.0 0.0 4096.0 14336.0)
      (set-root-prim! s5-0 s4-0)
      (let ((s2-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
        (set! (-> s2-0 prim-core collide-as) (collide-kind enemy))
        (set! (-> s2-0 collide-with) (collide-kind target))
        (set! (-> s2-0 prim-core action) (collide-action solid))
        (set! (-> s2-0 prim-core offense) (collide-offense indestructible))
        (set! (-> s2-0 transform-index) arg0)
        (set-vector! (-> s2-0 local-sphere) 0.0 0.0 0.0 6553.6)
        (append-prim s4-0 s2-0))
      (let ((s3-1 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
        (set! (-> s3-1 prim-core collide-as) (collide-kind enemy))
        (set! (-> s3-1 collide-with) (collide-kind target))
        (set! (-> s3-1 prim-core action) (collide-action solid))
        (set! (-> s3-1 prim-core offense) (collide-offense indestructible))
        (set! (-> s3-1 transform-index) 57)
        (set-vector! (-> s3-1 local-sphere) 0.0 4096.0 0.0 4096.0)
        (append-prim s4-0 s3-1)))
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (backup-collide-with-as s5-0)
    (set! (-> this root) s5-0))
  0
  (none))

(defmethod target-above-threshold? ((this fisher))
  (or (= (current-task (-> this tasks)) (game-task jungle-fishgame)) (-> this hard)))

(defmethod init-from-entity! ((this fisher) (arg0 entity-actor))
  (process-taskable-method-40 this arg0 *fisher-sg* 3 49 (new 'static 'vector :w 4096.0) 33)
  (set! (-> this tasks) (get-task-control (game-task jungle-fishgame)))
  (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (let ((s5-0 (eval-path-curve-div! (-> this path) (-> this paddle-pos) 6.5 'interp))
        (s4-0 (eval-path-curve-angle (-> this path) (new-stack-vector0) 6.5)))
    (+! (-> s5-0 y) 2457.6)
    (vector-normalize! (vector-rotate-y! s4-0 s4-0 16384.0) (-> *fisher-bank* width))
    (vector-! (the-as vector (-> this paddle-end)) s5-0 s4-0)
    (vector+! (the-as vector (&-> this stack 288)) s5-0 s4-0))
  (set! (-> this music) 'fishgame)
  (set! (-> this pity) (the-as int (-> this entity extra perm user-uint8 6)))
  (set! (-> this hard) #f)
  (set! (-> *fisher-bank* max-caught) 200)
  (set! (-> this training) #f)
  (process-taskable-method-42 this)
  (none))

(defstate target-fishing (target)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (cond
        ((= message 'bounce)
         (set-zero! (-> self control unknown-smush00))
         (activate! (-> self control unknown-smush00) 1.0 120 210 0.3 1.0))
        ((= message 'lose) (set! (-> self control unknown-uint20) (the-as uint message)) message)
        (else ((-> target-grab event) proc argc message block))))
  :enter
    (behavior ((arg0 handle))
      (set! (-> self control unknown-surface00) *empty-mods*)
      (logior! (-> self state-flags) (state-flags invulnerable))
      (set-zero! (-> self control unknown-smush00))
      (set! (-> self control unknown-uint20) (the-as uint #f)))
  :exit
    (behavior ()
      (logclear! (-> self state-flags) (state-flags invulnerable))
      (let ((v1-2 (-> self manipy)))
        (when v1-2
          (deactivate (-> v1-2 0))
          (set! (-> self manipy) (the-as (pointer manipy) #f))))
      (-> target-periscope exit))
  :code
    (behavior ((arg0 handle))
      (let ((v1-1 (handle->process arg0)))
        (when (and v1-1 (type-type? (-> v1-1 type) fisher))
          (set-vector! (-> self control trans) 1067827.2 9420.8 -955596.8 1.0)
          (set-yaw-angle-clear-roll-pitch! (-> self control) -20024.889)
          (rot->dir-targ! (-> self control))))
      (ja-channel-set! 1)
      (let ((s5-0 (get-process *default-dead-pool* manipy #x4000)))
        (set! (-> self manipy)
              (the-as (pointer manipy)
                      (when s5-0
                        (let ((t9-5 (method-of-type manipy activate))) (t9-5 (the-as manipy s5-0) self 'manipy (the-as pointer #x70004000)))
                        (let ((t9-6 run-function-in-process)
                              (a0-11 s5-0)
                              (a1-5 manipy-init)
                              (a2-2 (-> self control trans))
                              (v1-16 (handle->process arg0)))
                          ((the-as (function object object object object object object none) t9-6)
                           a0-11
                           a1-5
                           a2-2
                           (if v1-16 (-> v1-16 entity) (the-as entity-actor #f))
                           *fish-net-sg*
                           #f))
                        (-> s5-0 ppointer)))))
      (when (-> self manipy)
        (send-event (ppointer->process (-> self manipy)) 'anim-mode 'copy-parent)
        (send-event (ppointer->process (-> self manipy))
                    'eval
                    (lambda :behavior manipy ()
                      (set! (-> self joint 0) (new 'process 'joint-mod (joint-mod-handler-mode joint-set*) self 6))
                      (set! (-> self joint 1) (new 'process 'joint-mod (joint-mod-handler-mode joint-set*) self 5))
                      (none)))
        (let ((v1-35 (-> self manipy 0 node-list data)))
          (set! (-> v1-35 0 param0) cspace<-cspace+quaternion!)
          (set! (-> v1-35 0 param1) (the-as basic (joint-node eichar-lod0-jg sk_rhand)))
          (set! (-> v1-35 0 param2) (the-as basic (-> self control quat)))))
      (ja :group! eichar-fishing-ja :num! (identity (ja-aframe 15.0 0)))
      (let ((s5-2 (new 'stack-no-clear 'vector)))
        (until (-> self control unknown-spoolanim00)
          (let ((v1-42 (handle->process arg0)))
            (when v1-42
              (ja :num!
                  (seek! (* (fmax 0.0 (- 1.0 (-> (the-as fisher v1-42) paddle))) (the float (+ (-> (ja-group) data 0 length) -1)))))
              (when (-> self manipy)
                (let ((s2-0 (new-stack-vector0))
                      (s4-0 (new-stack-vector0))
                      (s3-0 (quaternion-identity! (new-stack-quaternion0)))
                      (f30-0 (update! (-> self control unknown-smush00))))
                  (quaternion-rotate-y! s3-0 s3-0 (* 5461.3335 f30-0))
                  (set-vector! s2-0 1.0 1.0 1.0 1.0)
                  (set-vector! s4-0 0.0 (* 2048.0 (-> s5-2 y)) (* 819.2 (-> s5-2 y)) 1.0)
                  (set-trs! (-> self manipy 0 joint 0) s4-0 s3-0 s2-0)
                  (set-vector! s4-0 0.0 (* -614.4 f30-0) 0.0 1.0)
                  (set-trs! (-> self manipy 0 joint 1) s4-0 (the-as quaternion #f) (the-as vector #f))
                  (set! (-> s5-2 y) (-> s5-2 x))
                  (set! (-> s5-2 x) f30-0)))))
          (suspend)))
      (case (-> self control unknown-spoolanim00)
        (('lose)
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! eichar-fishing-lose-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!)))
         (anim-loop))))
  :post target-post)
